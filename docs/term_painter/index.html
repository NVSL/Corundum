<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `term_painter` crate."><meta name="keywords" content="rust, rustlang, rust-lang, term_painter"><title>term_painter - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../term_painter/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate term_painter</p><div class="block version"><p>Version 0.3.0</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all term_painter's items</p></a><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><p class="location"></p><script>window.sidebarCurrent = {name: "term_painter", ty: "mod", relpath: "../"};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/term_painter/lib.rs.html#1-643" title="goto source code">[src]</a></span><span class="in-band">Crate <a class="mod" href="">term_painter</a></span></h1><div class="docblock"><p>This is a crate for coloring and formatting terminal output. Simple
example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">term_painter</span>;

<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">ToStyle</span>;
<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">Color</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">Attr</span>::<span class="kw-2">*</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} or {} or {}&quot;</span>,
        <span class="ident">Red</span>.<span class="ident">paint</span>(<span class="string">&quot;Red&quot;</span>),
        <span class="ident">Bold</span>.<span class="ident">paint</span>(<span class="string">&quot;Bold&quot;</span>),
        <span class="ident">Red</span>.<span class="ident">bold</span>().<span class="ident">paint</span>(<span class="string">&quot;Both!&quot;</span>)
    );
}</pre></div>
<p>This crate uses <a href="https://crates.io/crates/term"><code>rust-lang/term</code></a> to do the formatting. Of course,
you can use <code>term</code> directly, but it's kinda clumsy. Hence this library.</p>
<h2 id="how-to-use-it" class="section-header"><a href="#how-to-use-it">How to use it</a></h2>
<p>Formatting is done in two steps:</p>
<ol>
<li>
<p>Creating a style</p>
</li>
<li>
<p>Use this style to &quot;paint&quot; something and get a <code>Painted</code> object</p>
</li>
<li>
<p>Creating a style</p>
</li>
</ol>
<hr />
<p>To create a style a startpoint is needed: This can either be a startpoint
with an attached modifier (like <code>Red</code>: modifies the fg-color) or the
<code>Plain</code> startpoint, which does not modify anything.
After that, the startpoint can be modified with modifiers like <code>bold()</code> or
<code>fg()</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">term_painter</span>;

<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">ToStyle</span>;
<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">Color</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">Attr</span>::<span class="kw-2">*</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">5</span>;

    <span class="comment">// These two are equivalent: nothing is formatted/painted</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} | {}&quot;</span>, <span class="ident">x</span>, <span class="ident">Plain</span>.<span class="ident">paint</span>(<span class="ident">x</span>));

    <span class="comment">// These two are equivalent, too</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{} | {}&quot;</span>, <span class="ident">Red</span>.<span class="ident">paint</span>(<span class="ident">x</span>), <span class="ident">Plain</span>.<span class="ident">fg</span>(<span class="ident">Red</span>).<span class="ident">paint</span>(<span class="ident">x</span>));
}</pre></div>
<p>You can chain as many modifiers as you want. Every modifier overrides
preceding modifier:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">

<span class="comment">// blue, not red</span>
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">Plain</span>.<span class="ident">fg</span>(<span class="ident">Red</span>).<span class="ident">fg</span>(<span class="ident">Blue</span>).<span class="ident">paint</span>(<span class="string">&quot;Apple&quot;</span>));</pre></div>
<ol start="2">
<li>Use the style</li>
</ol>
<hr />
<p>After building the style, you can use it in two different ways.</p>
<p>One way is to call <code>paint</code> to use it on some object.
<code>paint</code> will return the wrapper object <code>Painted</code> that holds your object and
the specified style. <code>Painted</code> implements any formatting trait (like
<code>Display</code> and <code>Debug</code>) if and only if the type of the given Object, <code>T</code>,
does. So a <code>Painted</code> object can be printed via <code>println!</code> or similar macros.
When it gets printed, it will apply the given style before printing the
object of type <code>T</code> and will reset the style after printing.</p>
<p><code>Note</code>: <code>paint</code> will consume the passed object. This is no problem when
passing constant literals (like <code>paint(&quot;cheesecake&quot;)</code>) or types that are
<code>Copy</code>. Otherwise it could be confusing because just printing should not
consume a variable. To prevent consuming, just pass a reference to the
object (with <code>&amp;</code>). Example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">term_painter</span>;

<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">ToStyle</span>;
<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">Color</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">Attr</span>::<span class="kw-2">*</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">non_copy</span> <span class="op">=</span> <span class="string">&quot;cake&quot;</span>.<span class="ident">to_string</span>();  <span class="comment">// String is *not* Copy</span>
    <span class="kw">let</span> <span class="ident">copy</span> <span class="op">=</span> <span class="number">27</span>;  <span class="comment">// i32 *is* Copy</span>

    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">Plain</span>.<span class="ident">paint</span>(<span class="kw-2">&amp;</span><span class="ident">non_copy</span>));
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">Plain</span>.<span class="ident">paint</span>(<span class="kw-2">&amp;</span><span class="ident">copy</span>));
    <span class="comment">// non_copy is still usable here...</span>
    <span class="comment">// copy is still usable here...</span>

    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">Plain</span>.<span class="ident">paint</span>(<span class="ident">non_copy</span>));
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">Plain</span>.<span class="ident">paint</span>(<span class="ident">copy</span>));
    <span class="comment">// non_copy was moved into `paint`, so it not usable anymore...</span>
    <span class="comment">// copy is still usable here...</span>
}</pre></div>
<p>Another way is to call <code>with</code>. <code>with</code> takes another function (usually a
closure) and everything that is printed within that closure is formatted
with the given style. Specifically, <code>with()</code> sets the given style,
calls the given function and resets the style afterwards. It can be
chained and used together with <code>paint()</code>. Inner calls will overwrite
outer calls of <code>with</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">term_painter</span>;

<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">ToStyle</span>;
<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">Color</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">term_painter</span>::<span class="ident">Attr</span>::<span class="kw-2">*</span>;

<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="ident">Red</span>.<span class="ident">with</span>(<span class="op">|</span><span class="op">|</span> {
        <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;JustRed&quot;</span>);
        <span class="ident">Bold</span>.<span class="ident">with</span>(<span class="op">|</span><span class="op">|</span> {
            <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot; BoldRed {} BoldRed &quot;</span>, <span class="ident">Underline</span>.<span class="ident">paint</span>(<span class="string">&quot;Underline&quot;</span>));
        });
        <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;JustRed &quot;</span>);

         <span class="macro">print</span><span class="macro">!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">Blue</span>.<span class="ident">paint</span>(<span class="string">&quot;Blue (overwrite) &quot;</span>));
         <span class="ident">Green</span>.<span class="ident">with</span>(<span class="op">|</span><span class="op">|</span> {
             <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Green (overwrite)&quot;</span>);
         });
    });
}</pre></div>
<h2 id="some-notes" class="section-header"><a href="#some-notes">Some Notes</a></h2>
<p>If you don't want to pollute your namespace with <code>Color</code> and <code>Attr</code> names,
you can use a more qualified name (<code>Color::Red.paint(..)</code>) and remove these
<code>use</code> statements:</p>
<ul>
<li><code>use term_painter::Color::*;</code></li>
<li><code>use term_painter::Attr::*;</code></li>
</ul>
<p>Please note that global state is changed when printing a <code>Painted</code>
object. This means that some state is set before and reset after printing.
This means that, for example, using this library in <code>format!</code> or <code>write!</code>
won't work. The color formatting is not stored in the resulting string.
Although Unix terminals do modify color and formatting by printing special
control characters, Windows and others do not. This library uses the
plattform independent library <code>term</code>, thus saving formatted text in a
string not possible. This was a design choice.</p>
<p>This crate also assumes that the terminal state is not altered by anything
else. Calling <code>term</code> function directly might result in strange behaviour.
This is due to the fact that one can not read the current terminal state.
In order to work like this, this crate needs to track terminal state
itself. However, there shouldn't be any problems when the terminal state
is completely reset in between using those two different methods.</p>
<p>Another possible source of confusion might be multithreading. Terminal
state and handles are hold in thread local variables. If two terminal
handles would reference the same physical terminal, those two threads could
interfere with each other. I have not tested it, though. Usually, you don't
want to print to the same Terminal in two threads simultanously anyway.</p>
<p>Functions of <code>term</code> sometimes return a <code>Result</code> that is <code>Err</code> when the
function fails to set the state. However, this crate silently ignores those
failures. To check the capabilities of the terminal, use <code>term</code> directly.</p>
</div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.Painted.html" title="term_painter::Painted struct">Painted</a></td><td class="docblock-short"><p>Wraps an object of type <code>T</code> and a style. When attempting to print it, the
given style is applied before printing and reset afterwards.
All formatting traits (<code>Display</code>, <code>Debug</code>, ...) that are implemented
for <code>T</code> are also implemented the wrapper type <code>Painted&lt;T&gt;</code>.</p>
</td></tr><tr class="module-item"><td><a class="struct" href="struct.Style.html" title="term_painter::Style struct">Style</a></td><td class="docblock-short"><p>Saves all properties of a style. Implements <code>ToStyle</code>, so you can call
style modifiers on it.</p>
</td></tr></table><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<table><tr class="module-item"><td><a class="enum" href="enum.Attr.html" title="term_painter::Attr enum">Attr</a></td><td class="docblock-short"><p>Lists possible attributes. It implements <code>ToStyle</code> so it's possible to call
<code>ToStyle</code>'s methods directly on a <code>Attr</code> variant like:</p>
</td></tr><tr class="module-item"><td><a class="enum" href="enum.Color.html" title="term_painter::Color enum">Color</a></td><td class="docblock-short"><p>Lists all possible Colors. It implements <code>ToStyle</code> so it's possible to call
<code>ToStyle</code>'s methods directly on a <code>Color</code> variant like:</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.ToStyle.html" title="term_painter::ToStyle trait">ToStyle</a></td><td class="docblock-short"><p>Everything that can be seen as part of a style. This is the core of this
crate. All functions (&quot;style modifier&quot;) consume self and return a modified
version of the style.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "term_painter";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>