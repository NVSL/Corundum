<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `corundum` crate."><meta name="keywords" content="rust, rustlang, rust-lang, corundum"><title>corundum - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings"></script><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../favicon.svg">
<link rel="alternate icon" type="image/png" href="../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../corundum/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><p class="location">Crate corundum</p><div class="block version"><p>Version 0.2.2</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all corundum's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li></ul></div><p class="location"></p><script>window.sidebarCurrent = {name: "corundum", ty: "mod", relpath: "../"};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/corundum/lib.rs.html#1-177" title="goto source code">[src]</a></span><span class="in-band">Crate <a class="mod" href="">corundum</a></span></h1><div class="docblock"><p><em>Corundum</em> is a crate with an idiomatic persistent memory programming
interface and leverages Rust’s type system to statically avoid
most common persistent memory programming bugs. Corundum lets programmers
develop persistent data structures using familiar Rust constructs and have
confidence that they will be free of those bugs.</p>
<h1 id="statically-prevented-bugs" class="section-header"><a href="#statically-prevented-bugs">Statically Prevented Bugs</a></h1><table><thead><tr><th>Common Bugs</th><th>Explanation  <img width=700/></th><th>Approach</th></tr></thead><tbody>
<tr><td>Inter-Pool Pointers</td><td>A pointer in another pool which is unavailable</td><td>Type checking pools in persistent pointers.</td></tr>
<tr><td>P-to-V Pointers</td><td>A persistent pointer pointing at demote memory</td><td>Persistent pointers accept only <a href="./trait.PSafe.html"><code>PSafe</code></a> types and demote pointers are <code>!PSafe</code>. Only, <a href="./cell/struct.VCell.html"><code>VCell</code></a> allows single-execution P-to-V pointers.</td></tr>
<tr><td>V-to-P Pointers</td><td>A demote pointer keeping a zero-referenced object alive</td><td>Only <a href="./prc/struct.VWeak.html"><code>VWeak</code></a> allows V-to-P pointers which is a weak reference and does not keep data alive.</td></tr>
<tr><td>Unlogged Updates</td><td>An unrecoverable update to persistent data</td><td>Modifications are enforced to be inside atomic <a href="./alloc/trait.MemPool.html#method.transaction"><code>transaction</code></a>s.</td></tr>
<tr><td>Data Race</td><td>Updating persistent data simultaneously in two threads</td><td>Mutable borrowing is limited to <a href="./sync/struct.Mutex.html"><code>Mutex</code></a> which uses a transaction-wide lock to provide both atomicity and isolation.</td></tr>
<tr><td>Locked Mutex</td><td>A persistent mutex remains locked on powerfail</td><td><a href="./sync/struct.Mutex.html"><code>Mutex</code></a> uses <a href="./cell/struct.VCell.html"><code>VCell</code></a> which resets at restart.</td></tr>
<tr><td>Memory Leaks*</td><td>An allocated memory becomes unreachable</td><td>Persistent objects, except the root object, cannot cross transaction boundaries, and memory allocation is available only inside a transaction. Therefore, the allocation can survive only if there is a reference from the root object (or a decedent of it) to the data. <br>* Cyclic references are not prevented in this version, which lead to a memory leak.</td></tr>
</tbody></table>
<h1 id="persistent-objects" class="section-header"><a href="#persistent-objects">Persistent Objects</a></h1>
<p>Persistent objects in Corundum are available through persistent pointers:</p>
<ul>
<li><a href="./boxed/struct.Pbox.html"><code>Pbox</code></a>: A pointer type for persistent memory allocation.</li>
<li><a href="./prc/struct.Prc.html"><code>Prc</code></a>: A single-threaded reference-counting persistent pointer.</li>
<li><a href="./sync/struct.Parc.html"><code>Parc</code></a>: A thread-safe reference-counting persistent pointer.</li>
</ul>
<h1 id="programming-model" class="section-header"><a href="#programming-model">Programming Model</a></h1>
<p>Persistent memory is available as a file on a DAX-enable file system such as
EXT4-DAX or NOVA. These files are called memory pools. Corundum allows
memory pool types rather than memory pool objects to enforce pointer safety
while compilation. The trait <a href="./alloc/trait.MemPool.html"><code>MemPool</code></a> provides the necessary
functionalities for the pool type.</p>
<p>The first step is to open a memory pool file in the program to be able to
work with persistent data. The <a href="./alloc/default/index.html"><code>default</code></a> module provides a default memory
pool type (<a href="./alloc/default/struct.BuddyAlloc.html"><code>BuddyAlloc</code></a>). To open a pool, we can invoke <a href="./alloc/struct.MemPool.html#method.open"><code>open&lt;T&gt;()</code></a>
function which [initializes and] returns a reference to the root object of
type <code>T</code>. </p>
<p>Data modification is provided and allowed only through <a href="./alloc/trait.MemPool.html#method.transaction"><code>transaction</code></a>al
interface. None of the persistent pointers is mutably dereferencing for
safety. Mutable objects are allowed via interior mutability of any of the
following memory cells:</p>
<ul>
<li><a href="./cell/struct.PCell.html"><code>PCell&lt;T,P&gt;</code></a> (or <a href="./alloc/default/type.PCell.html"><code>PCell&lt;T&gt;</code></a>): An unborrowable, mutable persistent
memory location for a value of type <code>T</code> in pool <code>P</code>.</li>
<li><a href="./cell/struct.PRefCell.html"><code>PRefCell&lt;T,P&gt;</code></a> (or <a href="./alloc/default/type.PRefCell.html"><code>PRefCell&lt;T&gt;</code></a>): A mutable persistent memory location
with dynamically checked borrow rules for a value of type <code>T</code> in pool <code>P</code>.</li>
<li><a href="./sync/struct.Mutex.html"><code>Mutex&lt;T,P&gt;</code></a> (or <a href="./alloc/default/type.PMutex.html"><code>PMutex&lt;T&gt;</code></a>): A mutual exclusion primitive useful for
protecting shared persistent data of type <code>T</code> in pool <code>P</code>.</li>
</ul>
<p>The following example creates a pool file for a linked-list-based stack,
obtains a root object of type <code>Node</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">corundum</span>::<span class="ident">default</span>::<span class="kw-2">*</span>;
 
<span class="comment">// Aliasing the pool type for convenience</span>
<span class="kw">type</span> <span class="ident">P</span> <span class="op">=</span> <span class="ident">BuddyAlloc</span>;
 
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Root</span>)]</span>
<span class="kw">struct</span> <span class="ident">Node</span> {
    <span class="ident">value</span>: <span class="ident">i32</span>,
    <span class="ident">next</span>: <span class="ident">PRefCell</span><span class="op">&lt;</span><span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Prc</span><span class="op">&lt;</span><span class="ident">Node</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>
}
 
<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">head</span> <span class="op">=</span> <span class="ident">P</span>::<span class="ident">open</span>::<span class="op">&lt;</span><span class="ident">Node</span><span class="op">&gt;</span>(<span class="string">&quot;foo.pool&quot;</span>, <span class="ident">O_CF</span>).<span class="ident">unwrap</span>();
 
    <span class="ident">P</span>::<span class="ident">transaction</span>(<span class="op">|</span><span class="ident">j</span><span class="op">|</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">h</span> <span class="op">=</span> <span class="ident">head</span>.<span class="ident">next</span>.<span class="ident">borrow_mut</span>(<span class="ident">j</span>);
        <span class="kw-2">*</span><span class="ident">h</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">Prc</span>::<span class="ident">new</span>(<span class="ident">Node</span> {
            <span class="ident">value</span>: <span class="ident">rand</span>::<span class="ident">random</span>(),
            <span class="ident">next</span>: <span class="ident">head</span>.<span class="ident">next</span>.<span class="ident">pclone</span>(<span class="ident">j</span>)
        }, <span class="ident">j</span>));
    }).<span class="ident">expect</span>(<span class="string">&quot;Unsuccessful transaction&quot;</span>);
}</pre></div>
</div><h2 id="reexports" class="section-header"><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use stm::<a class="fn" href="../corundum/stm/fn.transaction.html" title="fn corundum::stm::transaction">transaction</a>;</code></td></tr></table><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<table><tr class="module-item"><td><a class="mod" href="alloc/index.html" title="corundum::alloc mod">alloc</a></td><td class="docblock-short"><p>Persistent Memory allocation APIs</p>
</td></tr><tr class="module-item"><td><a class="mod" href="boxed/index.html" title="corundum::boxed mod">boxed</a></td><td class="docblock-short"><p>A persistent pointer type for persistent memory allocation</p>
</td></tr><tr class="module-item"><td><a class="mod" href="cell/index.html" title="corundum::cell mod">cell</a></td><td class="docblock-short"><p>Persistent shareable mutable containers</p>
</td></tr><tr class="module-item"><td><a class="mod" href="clone/index.html" title="corundum::clone mod">clone</a></td><td class="docblock-short"><p>The <code>PClone</code> trait for types that cannot be 'implicitly copied'</p>
</td></tr><tr class="module-item"><td><a class="mod" href="convert/index.html" title="corundum::convert mod">convert</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="mod" href="default/index.html" title="corundum::default mod">default</a></td><td class="docblock-short"><p>The default allocator module</p>
</td></tr><tr class="module-item"><td><a class="mod" href="ll/index.html" title="corundum::ll mod">ll</a></td><td class="docblock-short"><p>Low-level utils</p>
</td></tr><tr class="module-item"><td><a class="mod" href="prc/index.html" title="corundum::prc mod">prc</a></td><td class="docblock-short"><p>Single-threaded reference-counting persistent pointers</p>
</td></tr><tr class="module-item"><td><a class="mod" href="ptr/index.html" title="corundum::ptr mod">ptr</a></td><td class="docblock-short"><p>Manually manage memory through raw pointers</p>
</td></tr><tr class="module-item"><td><a class="mod" href="result/index.html" title="corundum::result mod">result</a></td><td class="docblock-short"><p>A <code>Result</code> type with string error messages</p>
</td></tr><tr class="module-item"><td><a class="mod" href="stat/index.html" title="corundum::stat mod">stat</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="mod" href="stm/index.html" title="corundum::stm mod">stm</a></td><td class="docblock-short"><p>Software transactional memory APIs</p>
</td></tr><tr class="module-item"><td><a class="mod" href="str/index.html" title="corundum::str mod">str</a></td><td class="docblock-short"><p>Persistent unicode string slices</p>
</td></tr><tr class="module-item"><td><a class="mod" href="sync/index.html" title="corundum::sync mod">sync</a></td><td class="docblock-short"><p>Useful synchronization primitives</p>
</td></tr><tr class="module-item"><td><a class="mod" href="vec/index.html" title="corundum::vec mod">vec</a></td><td class="docblock-short"><p>A contiguous growable array type with heap-allocated contents, written Vec<T></p>
</td></tr></table><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<table><tr class="module-item"><td><a class="macro" href="macro.log.html" title="corundum::log macro">log</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="macro" href="macro.measure.html" title="corundum::measure macro">measure</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="macro" href="macro.pool.html" title="corundum::pool macro">pool</a></td><td class="docblock-short"><p>This macro creates a new pool module and aliases for persistent types. It
generates type <a href="./alloc/default/struct.BuddyAlloc.html"><code>BuddyAlloc</code></a> which a persistent allocator type. It is
recommended to alias the <a href="./alloc/default/struct.BuddyAlloc.html"><code>BuddyAlloc</code></a> type for tidiness.</p>
</td></tr><tr class="module-item"><td><a class="macro" href="macro.static_inner.html" title="corundum::static_inner macro">static_inner</a></td><td class="docblock-short"><p>This macro can be used to access static data of an arbitrary allocator</p>
</td></tr></table><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<table><tr class="module-item"><td><a class="struct" href="struct.AssertTxInSafe.html" title="corundum::AssertTxInSafe struct">AssertTxInSafe</a></td><td class="docblock-short"><p>A simple wrapper around a type to assert that it is safe to go in a
transaction.</p>
</td></tr></table><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<table><tr class="module-item"><td><a class="trait" href="trait.LooseTxInUnsafe.html" title="corundum::LooseTxInUnsafe trait">LooseTxInUnsafe</a></td><td class="docblock-short"><p>The implementing type can be asserted <a href="./trait.TxInSafe.html"><code>TxInSafe</code></a> albeit being <code>!TxInSafe</code>
by <a href="./struct.AssertTxInSafe.html"><code>AssertTxInSafe</code></a>.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.PSafe.html" title="corundum::PSafe trait">PSafe</a></td><td class="docblock-short"><p>It marks the implementing type to be free of pointers to the demote heap,
and persistence safe.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.PSend.html" title="corundum::PSend trait">PSend</a></td><td class="docblock-short"><p>Safe to be sent to another thread</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.RootObj.html" title="corundum::RootObj trait">RootObj</a></td><td class="docblock-short"><p>Creates a default value of the type</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.TxInSafe.html" title="corundum::TxInSafe trait">TxInSafe</a></td><td class="docblock-short"><p>It is equal to UnwindSafe, but is used to ensure doubly that mutable
references cannot go inside a transaction.</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.TxOutSafe.html" title="corundum::TxOutSafe trait">TxOutSafe</a></td><td class="docblock-short"><p>It marks the implementing type to be safe crossing transaction boundaries</p>
</td></tr><tr class="module-item"><td><a class="trait" href="trait.VSafe.html" title="corundum::VSafe trait">VSafe</a></td><td class="docblock-short"><p>Safe to be stored in demote memory useful in <code>VCell</code> type to prevent
storing persistent pointers in <a href="./cell/struct.VCell.html"><code>VCell</code></a></p>
</td></tr></table><h2 id="derives" class="section-header"><a href="#derives">Derive Macros</a></h2>
<table><tr class="module-item"><td><a class="derive" href="derive.PClone.html" title="corundum::PClone derive">PClone</a></td><td class="docblock-short"></td></tr><tr class="module-item"><td><a class="derive" href="derive.Root.html" title="corundum::Root derive">Root</a></td><td class="docblock-short"></td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "corundum";</script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>